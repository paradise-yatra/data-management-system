import express from 'express';
import Trash from '../models/Trash.js';
import Identity from '../models/Identity.js';
import { authenticateToken, authorizeRoles } from '../middleware/auth.js';
import { createLog } from '../utils/logger.js';

const router = express.Router();

// All routes require authentication
router.use(authenticateToken);

// Get current date and time in Indian Standard Time (IST)
const getISTDateTime = () => {
  const now = new Date();
  
  // Get IST time using toLocaleString
  const istString = now.toLocaleString('en-US', {
    timeZone: 'Asia/Kolkata',
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false,
  });
  
  // Parse the IST string and format as ISO
  // Format: MM/DD/YYYY, HH:MM:SS
  const [datePart, timePart] = istString.split(', ');
  const [month, day, year] = datePart.split('/');
  const [hours, minutes, seconds] = timePart.split(':');
  
  return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}+05:30`;
};

// Get all trash records
router.get('/', async (req, res) => {
  try {
    const trashRecords = await Trash.find().sort({ deletedAt: -1 });
    res.json(trashRecords);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Add a record to trash
router.post('/', async (req, res) => {
  try {
    const { uniqueId, name, email, phone, interests, source, remarks, dateAdded } = req.body;

    if (!source || !source.trim()) {
      return res.status(400).json({ error: 'Source is required' });
    }

    const trashRecord = new Trash({
      uniqueId: uniqueId || '',
      name: (name && typeof name === 'string' && name.trim()) ? name.trim() : '',
      email: email?.trim() || '',
      phone: phone?.trim() || '',
      interests: Array.isArray(interests) ? interests : [],
      source: source.trim(),
      remarks: remarks?.trim() || '',
      dateAdded: dateAdded || new Date().toISOString(),
      deletedAt: new Date(),
    });

    await trashRecord.save();
    res.status(201).json(trashRecord);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Restore a record from trash (move it back to identities)
router.post('/:id/restore', async (req, res) => {
  try {
    const trashRecord = await Trash.findById(req.params.id);
    
    if (!trashRecord) {
      return res.status(404).json({ error: 'Trash record not found' });
    }

    // Check if identity with same email or phone already exists
    if (trashRecord.email && trashRecord.email.trim()) {
      const existingEmail = await Identity.findOne({ email: trashRecord.email.trim() });
      if (existingEmail) {
        return res.status(400).json({ error: 'An entry with this email already exists' });
      }
    }
    
    if (trashRecord.phone && trashRecord.phone.trim()) {
      const existingPhone = await Identity.findOne({ phone: trashRecord.phone.trim() });
      if (existingPhone) {
        return res.status(400).json({ error: 'An entry with this phone number already exists' });
      }
    }

    // Create new identity from trash record (treat as fresh entry)
    // Don't set uniqueId - let the pre-save hook generate a new one
    // Update dateAdded to current time since it's a new entry
    const identity = new Identity({
      // uniqueId will be auto-generated by pre-save hook
      name: trashRecord.name,
      email: trashRecord.email,
      phone: trashRecord.phone,
      interests: trashRecord.interests,
      source: trashRecord.source,
      remarks: trashRecord.remarks,
      dateAdded: getISTDateTime(), // New date/time for the restored entry
    });

    await identity.save();
    
    // Get the saved identity with the new uniqueId
    const savedIdentity = await Identity.findById(identity._id);
    
    // Log the restore action
    await createLog('restore_identity', req, {
      uniqueId: savedIdentity.uniqueId,
      originalUniqueId: trashRecord.uniqueId,
      name: savedIdentity.name || 'N/A',
    });
    
    // Delete from trash
    await Trash.findByIdAndDelete(req.params.id);
    
    res.json(savedIdentity);
  } catch (error) {
    if (error.name === 'ValidationError') {
      const messages = Object.values(error.errors).map((e) => e.message);
      return res.status(400).json({ error: messages.join(', ') });
    }
    res.status(500).json({ error: error.message });
  }
});

// Permanently delete a record from trash
router.delete('/:id', async (req, res) => {
  try {
    const trashRecord = await Trash.findByIdAndDelete(req.params.id);
    
    if (!trashRecord) {
      return res.status(404).json({ error: 'Trash record not found' });
    }
    
    // Log the action
    await createLog('delete_from_trash', req, {
      uniqueId: trashRecord.uniqueId,
      name: trashRecord.name || 'N/A',
    });
    
    res.json({ message: 'Record permanently deleted from trash' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Empty trash (delete all records)
router.delete('/', async (req, res) => {
  try {
    const result = await Trash.deleteMany({});
    
    // Log the action
    await createLog('empty_trash', req, {
      count: result.deletedCount,
    });
    
    res.json({ message: `Deleted ${result.deletedCount} record(s) from trash` });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

export default router;

